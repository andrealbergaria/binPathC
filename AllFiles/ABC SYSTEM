----------------------------------------------					
					ABC SYSTEM
-----------------------------------------------

                Can represent integer,real numbers, etc...
                  A = 000
      			  B = 001
      			  C = 010
      			  D = 100
      			  E = 111
      			  F = 110
      			  G = 101
      			  H = 011
      			  
      			  
      			  
      			   
                 A = 00 and 01
                    b = 10 and 11
                    
                    A A A A
                    B A A A
                    
                    A = 0000 and 0001 and 0010 and 0011
                    B = 0100 and 0101 and 0110 and 0111
                    C = 1000 and 1001 and 1010 and 1011
                    D = 1100
                    
                   or with one letter for 2 numbers
                   
                   A = 0000 and 0001
                   B = 0010 and 0011
                   C = 0100 and 0101
                   D = 0111 and 1000
                   E = 1001 and 1010
                   F = 1011 and 1111
                   
                A = 0000 rev(A) = 1111
                B = 0001 rev(b) = 1110
                C = 0010 rev(c) = 1101 
                D = 0011 rev(D) = 1100
                E = 0100 rev(E) = 1011
                F = 0101 rev(F) = 1010
                H = 0110 rev(H)=  1001
                G = 0111 rev(G) = 1000
                
                 
                 // for each bit , there is a change in the set. position or substituing
                  // solution Assign zero=0 a=01 b=10 e c=11  one=a each symbol is equal to the last plus one 
				
				reverse of (z) = o
             reverse of (a) = b
             reverse of (b) = a
             reverse of (c) = z
             reverse of (o) = z
                
                The numbers can be combined with bits. If the number of bits is odd, then add a zero (letter z) to the number an concat
           the symbols
           
                                    
             // All shifts will generate number composed of (z,a,b,c)
             
              
                 
                 (1 0 1 1 0 0 ) = (c,d,a)
                 
                 (1 1 0 1 0 1 ) = (d,b,b)
                 
             	FOR ODD NUMBER OF BITS WE ASSUME A LEADING ZERO
                 
                 (1 0 1 1 0 1 1) = (a,a,b,c)
                 
                 Added zero at beggining
                 (0 1 0 1 1 0 1 1) = (a,a,b,c)
                           
                       That means that shifting , in the ABC SYSTEM, is presents algebra closure (useful for turing machine) 
                       Also ...it uses modular arithemtic. 
                       It is transitive as well
             
             
             	azz + 1  => aza (modular arithmetic) 
                zzb +1   => zzc (normal addition)
             
             
             Shift 4 bits => 000010 z,z,b
             				 000100 z,a,z
             				 001000 z,b,z
             				 010000 a,z,z
             				 100000 b,z,z
             
             				 
             When added , for example 
             		azz+1 = aza
             		zzb +1  = zzc
             		zzc+1 = zzz
             		
        
                 
                
                
                01 00 00 => +1   => 01 00 01
                a  z   z            a  z  a
                
                00 00 10 => +1 => 00 00 11
                z  z  b           z  z  c 
                
                01 01 00 => +1 => 01 01 01
                a  a  z             a   a  a
                
                11 11 00 => +1 =>  11 11 01
                c  c  z             c c a           
                
                
             
               01 01 00 => +1 => 01 01 01
               a  a  z           a  a  a
               
               
               
               10 00 00 => -1 => acc
                b  z  z 
               01 00 00 => -1 => zcc
                a  z   z
                
                
                
                
                
                -1,-2,-3,4 = change in the third position
                -5,-6,-7,-8 = change in the third position
                -9,-10,-11-12 = change in the third position
                -13,-14,-15,-16 = change in the third position
                -8,-9 = bbz -> bac = 
                -12,-13 = baz -> bzc = 
                -16,-17 = bzz -> acc
                -20,-21 = acz -> zbz = 
                
                bcz = 101100
                baz = 100100
                
                
                00 10 01 (1+8) = 9  zba
                00 10 10 (2+8) = 10 zbb
                00 10 11 (3+8) = 11 zbc

			    01 10 01 = (9+16)
			    01 10 10 = (10+16) 
			                    
                101100 = bcz
                101101 = (13+32) = 45
                101110 = (14+32)
                
                100000
                
                complemento para dois
                101100
                100100
                
                inverting bits and add one
                
                
                
                subtraction equals 8
                
     here)           so from baz to bzc , there are 8 positions
                string t = counting from the original
                    baz +1 t = baa
                    baa +2 t = bab
                    bac +3 t = bbb
                    baz +4 t = bbz
                    baz +5 t = bba
                    bar +6 t = bbb
                    bar +7 t = bbc
                    bar +8 t = bcz
                    
                    so from acz to zbz = -20,-21
                    acz +1 t = aca
                    acz +2 t = acb
                    acz +3 t = acc
                    acz +4 t = bzz 
                    acz +5 t = bza
                    acz +6 t = bzb
                    acz +7 t = bzc
                    acz+8 t =  baz
                    acz+9 t =  baa
                    acz+10 t = bab
                    acz+11 t = bac (t2)
                    acz+12 t = bbz
                    acz+13 t = bba
                    acz+14 t = bbb (t2)
                    acz+15 t = bbc (t2)
                    acz+16 t = bcz
                    acz+17 t = bca
                    acz+18 t = bcb
                    acz+19 t = bcc (t2)
                    acz+20 t  =czz                  
               11 00 00 (czz) => -1 => bcc
                                 -2 => bcb
                                 -3 => bca
                                 -4 => bcz
                                 -5 => bbc (subtracts 2pos from previous and adds z to c from -1)
                                 -6 => bbb
                                 -7 => bba
                                 -8 >= bbz
                                 -9 => bac (subtracts 2nd pos and adds z to c)
                                 -10=> bab
                                 -11 => baa
                                 
                                 -12 => baz
                                 -13 => bzc (adds 8 positions , check here)
                                 
                                 -14 => bzb
                                 -15 => bza (t2)
                                 -16 => bzz (t2)
                                 -17 => acc 
                                 -18 => acb (t2)
                                 -19 => aca (t2)
                                 
                                 -20 => acz (t2)
                                 
                                    adds(last, and makes a carry from c-> b,
                                        z -1  = 
                                        ab
                                    )
                                 -21 => abc 
                                 
                                 20 em binario =  = 010100
                                 21 em binario = 010101
                                 11 00 00
                                 
                                 
                                 -22 => caz
                                 
                                 
                                 // base 00 00 01
                                 +1 => 00 00 10 (zzb)
                                 +2 => 00 00 11 (zzc)
                                 +3 => 00 01 00 (zaz)
                                 +4 => 00 01 01 (zaa)
                                 -1 => 00 00 00 (zzz)
                                 -2 => ???
                
                                // base 11 01 00
                                    +1 =>  caa
                                    +2 =>  cab
                                    +3 =>  cac
                                    +4 =>  cbz
                                    -1 =>  czc
                                    -2 =>  czb
                                    -3 =>  cza
                                    -4 =>  czz
                
                z = 0
                a = z + 1 = 01;
                b = z + 2 = 10 and b= a+1 
                c = z + 3 = 11 and c= b+1
                o = c = 1
                
                //b z (shift left 4 bits)
                
                
                
               xhg(a,b) = ba
               
               
               
                [z,a,b,c] 4*4*4 = 64
                
                 {[1,2,3] = perumtations with repetations= 27
                
                
                    xor = equivalent to adding +2 to a number
                            
                        (baa == caa) // change in one pos (not from base)
                        (aba == abb)
                        (aab == bab)
                       
                        bab = aba (inverse) = bba (shift) = baa (shift) = caa (shift) = acc(inverse) = aca (shift)
                        = cac (reverse) = cab (shift) = aab (shfit) = acb (shift) = ccb (shift) = cca(shift)
                        = bca(shift) = bcc(shift)
                        
                      
                        
                        
                                
                                shift (da base bbb)  shift  shift
                    1)    (abb ==     bab         == bba == 
                        
                                shift (da base aaa)
                   2)     (baa == aba == aab)
                        
                                shift (da base ccc)
                   3)     (acc = cac == cca )
                        
                                shift(base aaa)
                   4)     caa = aca = aac 
                        
                        
                                shift(base bbb)
                   5)   cbb => bcb => bbc
                        
                                shift(base ccc)
                   6)     bcc => cbc => ccb
                        
                        
                        using two bases, we can invert the result(for example  reverte the results in 1) to 2)"
                        
                    
                    // base(aaa)
              2)    baa 
                    aba
                    aab
                    
                    abb // inverse a 2 , base bbb
                    bab  
                    bba
                    
                    
                    // base (ccc)
              3)    acc
                    cac
                    cca
                    
                    // nao precisa de base (inverse of 3) base aaa
                    caa
                    aca
                    aac
                    
                    
                    //base ccc
                4)  bcc
                    cbc
                    ccb
                    
                    cbb // base bbb inverse of 4)
                    bcb
                    bbc

  

            
    
    

use 1 bit b, shift it 3 times, like abb , bab,bba
                                    invert
                                    baa,aba,aab
                                    
use 1 bit b, shift it 3 times , cbb,bcb,bbc
                                invert
                                bcc,cbc,ccb

use 1 bit b, shift it 3 times , acc,cac,cca
                                caa,aca,aac
                                

                 for 0='b' and 1='a' ==> 3 ops
                 for 0='b' and 1='c' ==> 3 pos
                 
                 for 0='c' and 1='a' ==> 3 pos 
                 for 0='c' and 1='b' ==> 3 pos 
                     
                 
                 

                 
                 /* para cada shift right [01,10,11]
                  *                         a  b  c
                                          [00,01,10]
                                            z a b
                                          [00,00,01]
                                            z z a
                                          [00,00,00]
                                            z  z z
                para cada shift left [01,10,11]
                                       a  b c
                                     [10,11,00]
                                      b  c z
                                     [11,00,00]
                                     c z z
                                     [00,00,00
                                    z z z
                {[1,2,3] = perumtations with repetations= 27
               
               [1,2,3] is used (pos(0) = 1  , pos(1)= 2 , pos(2) = 3 (because on each position , one increments the before)
                                    
                 
                  assign 00000000 = [1,2,3]
                  assign 00000001 = {1,2,3]  (var=1 1 change to set)
                  assign 00000010 = {1,2,3]  (var=2 (correspond to 2 changes to set)
                  assign 00000100 = [1,2,3] (var=3 (correspond to 3 changes in set)
                  total permutations = 2+4+8+16+32+64+128+256 = 509 
                  
                  
                  
                  if it was binary code, then we would make a shift, in thise case we change pos
                      
                1)    100
                2)    010
                3)    001 pos(0) =pos(1),pos(2)=pos(1)  (2shifts, 0 -> 1 , 1->2, um shift uma posicao++)
                      
                     
                      3bits=8 orders
                      
                      e se eu fizer o shift, com posicao fixa no bit anterior
                      
                      01 01   ( ==> correspond to 100 , on the last seq (1)) 
                      01 10   ( ==! correspond to 010 , on the last seq(2) shift efectuado (01 01
                      10 10                                                                  01 10                                                                      
                      10 01   ( ==> correspond to 001, om the last seq(3) , shift efectuado (10 01
                                                                                            10 (01)
                                                                                                            
                    
                    num da posicao = numero binario (nao resulta)
                      000 = position(0)
                      001 = position(1)
                      010 = position(2)
                      100 = position(4)
                      
                      
                      
                     // equal one bit digit to a position, and other digit to a position  (1=1 0=2)
                     // 1=01 0=10
                     // so the bit 1 is equal to 1 position
                     // so the bit 0 is equal to 2 position
                     
                    so if the elements are two, then we case use the algorithm
                    
                    if the elements are three?
                        if the elements are three
                        => 000 (3bits) , 1st bit = 0 ... 2nd bit = 0 ...3rd bit = 0
                                                   1               1            1
                                        
                                        1st bit 
                                        1
                                        0
                                        
                                        if elements are 2 (like [a,b]), then 1st bit must be multiplied by 2
                                        1st bit must be 2nd bit uses 1st bit,
                                        
                                        2nd bit is 1bit , 1 bit
                                        
                                        0 0 A = (2nd bit = xor first bit ^ 0) 
                                        0 1 B = (2nd bit = xor first bit ^ 1 )
                                        1 0 C = (2nd bit = xor first bit ^ 1)
                                        1 1 D=  (2nd bit = xor first bit ^0 )
                                        
                                        B=C, A=D
                                        
                                        3 bits
                                        
						Only works for binaries (when i say not taken, it means zero)
                    bit 0 = pos(1)  if pos(1) is not set, then pos1 not taken ,then pos1 = 0
                    bit 1 = pos(2)  
                    bit 2 = pos(3)
                    
                    Get the zeros and then zero out positions accordingly
                    
                    Uma matriz de zeros e uns, que para cada 0 inibe a posicao da outra matriz ou toma outro valor qualquer 
                    
                    [ 1 0 1 ] [1 2 3] => [1 0 3]
                     
                    [0 0 1] [3 2 4] =>  [0 0 3]
                    
                   [ 1 0 1] [1 2 3] => [1 7 3]
                   
                   
                   Each symbol represents, one entrace in teh truth table 
                   
                   